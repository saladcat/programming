
### 字符串分割
``` c++
vector<string> split(const string &str, const string &delim) {
    vector<string> res;
    if ("" == str) return res;
    //先将要切割的字符串从string类型转换为char*类型
    char *strs = new char[str.length() + 1]; //不要忘了
    strcpy(strs, str.c_str());

    char *d = new char[delim.length() + 1];
    strcpy(d, delim.c_str());

    char *p = strtok(strs, d);
    while (p) {
        string s = p; //分割得到的字符串转换为string类型
        res.push_back(s); //存入结果数组
        p = strtok(NULL, d);
    }

    return res;
}

```
## 最短路算法
### dijkstra
``` c++
int dijkstra(int lowBoundPlace, int highBoundPlace) {
    memset(vis, 0, sizeof(vis));
    // init vis
    for (int i = 1; i <= N; i++) {
        if (gift[i].place < lowBoundPlace || gift[i].place > highBoundPlace) {
            vis[i] = 1;
        } else {
            dist[i] = distMaze[0][i];
        }
    }
    // find min dist index
    for (int time = 0; time < N; time++) {
        int minIndex = -1;
        int minDist = INF;
        for (int i = 1; i <= N; i++) {
            if (vis[i] == 0 && dist[i] < minDist) {
                minIndex = i;
                minDist = dist[i];
            }
        }
        if (minIndex < 0) {
            break;
        }
        vis[minIndex] = 1;
        // update minDist cause of  every other point through minPoint
        for (int i = 1; i <= N; i++) {
            if (vis[i] == 0 && dist[i] > minDist + distMaze[minIndex][i]) {
                dist[i] = minDist + distMaze[minIndex][i];
            }
        }
    }
    return dist[1];
}
```

### floyd
![](https://ws4.sinaimg.cn/large/006tKfTcly1g0quzi9tbuj30is0d4gn2.jpg)

## 最小生成树
### prim
```c++
void prim() {
    vis[0] = 1;
    memcpy(dist, distMaze[0], sizeof(dist));
    for (int k = 0; k < nodeNum; k++) {
        // findMinIndex
        int minIndex = -1;
        int minDist = INF;
        for (int i = 0; i < nodeNum; i++) {
            if (vis[i] == 0 && minDist > dist[i]) {
                minDist = dist[i];
                minIndex = i;
            }
        }
        if (minIndex == -1) {
            break;
        }
        vis[minIndex] = 1;
        for (int i = 0; i < nodeNum; i++) {
            if (vis[i] == 0 && dist[i] > distMaze[minIndex][i]) {
                dist[i] = distMaze[minIndex][i];
            }
        }
    }
    res = 0;
    for (int i = 1; i < nodeNum; i++) {
        res += dist[i];
    }
}
```

